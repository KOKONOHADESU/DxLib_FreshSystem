#pragma once

#include "Vec2.h"

#include <string>
#include <vector>
#include <map>
#include <DxLib.h>

/// <summary>
/// 画像関連
/// </summary>
namespace Graphic
{
	/// <summary>
	/// 画像管理
	/// </summary>
	/// <typeparam name="T">どのシーンで画像を読み込むかをしているする型</typeparam>
	/// <typeparam name="U">画像にIDをつける場合の型                    </typeparam>
	template <typename T , typename U>
	class DxLibGraphicFresh
	{
	public:
		DxLibGraphicFresh() {};
		~DxLibGraphicFresh() {};

	private:
		// 画像データ
		struct GrahicData
		{
			U id;                  // ID
			std::string graphPath; // 画像パス
			int handle;            // 画像データ
			Vec2 size;             // 画像サイズ
			T scene;               // 使用するシーン
			bool isNoEnd;          // どのシーンでもメモリを解放しない場合
		};

	public:		
		/// <summary>
		/// 画像読み込み
		/// </summary>
		/// <param name="id"      >画像ID                        </param>
		/// <param name="filePath">画像パス                      </param>
		/// <param name="scene"   >画像を使用するシーン          </param>
		/// <param name="isNoEnd" >複数のシーンで使用するかどうか</param>
		/// <returns              >false : 失敗 , true : 成功    </returns>
		bool LoadGrahic(const U& id ,const std::string& filePath , const T& scene , bool isNoEnd = false)
		{
			// データ取得用
			GrahicData data{};

			// IDの記録
			data.id = id;

			// 画像パスの記録
			data.graphPath = filePath;

			// 複数のシーンで画像を使用する場合
			if (isNoEnd)
			{
				// 画像のロード
				data.handle = LoadGraph(filePath.c_str());
			}
			else
			{
				// ここではまだ画像ロードしない
				data.handle = -1;
			}
		
			// 使用するシーン
			data.scene = scene;

			// 画像のサイズを取得
			GetGraphSizeF(data.handle, &data.size.x, &data.size.y);

			// 複数のシーンで使用するかどうか
			data.isNoEnd = isNoEnd;

			// 画像の追加
			m_graphData.push_back(data);

			// 読み込み成功したら
			return true;
		}

		/// <summary>
		/// 現在のシーンを確認する
		/// </summary>
		/// <param name="scene">現在のシーン</param>
		void SceneInput(T scene)
		{
			// すべての画像データを確認
			for (int i = 0; i < m_graphData.size(); i++)
			{
		
				// 特定の画像データを確認
				// 画像ロードしていないデータを確認
				if (m_graphData[i].scene == scene && m_graphData[i].handle == -1)
				{
					// 画像のロード
					m_graphData[i].handle = LoadGraph(m_graphData[i].graphPath.c_str());
					// 読み込み失敗したら
					if (m_graphData[i].handle == -1)return;				
				}
				// 他シーンで使用する画像の場合
				else if (m_graphData[i].scene != scene && !m_graphData[i].isNoEnd)
				{
					// 画像データが入っていた場合
					if (m_graphData[i].handle != -1)
					{					
						// メモリの解放
						DeleteGraph(m_graphData[i].handle);
						m_graphData[i].handle = -1;
					}
				}
			}			
		}

		/// <summary>
		/// 画像ハンドルを渡す
		/// </summary>
		/// <param name="id">画像ID        </param>
		/// <returns        >ハンドルデータ</returns>
		int GetHandle(const U& id)
		{
			int handle = -1;

			// すべての画像を確認
			for (int i = 0; i < m_graphData.size(); i++)
			{
				// 同じIDを探す
				if (m_graphData[i].id == id)
				{
					// 同じIDが見つかったらループを終了
					handle = m_graphData[i].handle;
					break;
				}
				
			}

			return handle;
		}

		/// <summary>
		/// 画像サイズを渡す
		/// </summary>
		/// <param name="id">画像ID      </param>
		/// <returns        >サイズを渡す</returns>
		Vec2 GetSize(const U& id)
		{
			Vec2 size = Vec2(0.0f,0.0f);

			// すべての画像を確認
			for (int i = 0; i < m_graphData.size(); i++)
			{
				// 同じIDを探す
				if (m_graphData[i].id == id)
				{
					// 同じIDが見つかったらループを終了
					size = m_graphData[i].size;
					break;
				}

			}

			return size;
		}

		/// <summary>
		/// メモリ解放
		/// </summary>
		void EndGrahics()
		{
			for (int i = 0; i < m_graphData.size(); i++)
			{
				// メモリの解放
				DeleteGraph(m_graphData[i].handle);
				m_graphData[i].handle = -1;
			}
		}

	private:
		// 画像データ				
		std::vector<GrahicData>m_graphData;
	};
}


